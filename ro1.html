<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constructorul Cunoașterii - Joc 3D</title>
    <!-- Tailwind CSS for UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; outline: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* Enable pointer events only for UI elements */
        .interactive-ui { pointer-events: auto; }

        /* Custom Scrollbar for Modal */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        .block-btn { background-size: cover; background-position: center; image-rendering: pixelated; } /* Pixel art style for buttons */
        .block-btn.active { border-color: #fbbf24; transform: scale(1.1); box-shadow: 0 0 10px #fbbf24; }
        .tool-btn.active { background-color: #fbbf24; color: #1e293b; transform: scale(1.05); }

        /* Loader */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="game-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-4">
        
        <!-- Header: Points and Stats -->
        <div class="flex justify-between items-start interactive-ui w-full">
            <!-- Left: Game Manager -->
            <button onclick="openSaveManager()" class="bg-slate-800/90 text-white p-4 rounded-xl border-2 border-slate-600 shadow-lg backdrop-blur-sm hover:bg-slate-700 transition-all flex items-center gap-2 mr-4">
                <i class="fas fa-save text-yellow-400"></i>
                <div class="flex flex-col items-start">
                    <span class="text-xs text-slate-400 uppercase font-bold tracking-wider">Joc Activ</span>
                    <span id="current-game-name" class="font-bold truncate max-w-[100px]">...</span>
                </div>
            </button>

            <!-- Center: Points -->
            <div class="bg-slate-800/90 text-white p-4 rounded-xl border-2 border-slate-600 shadow-lg backdrop-blur-sm flex-1 max-w-xs mx-auto">
                <div class="text-xs text-slate-400 uppercase font-bold tracking-wider">Resurse Disponibile</div>
                <div class="text-3xl font-bold text-yellow-400 flex items-center gap-2">
                    <i class="fas fa-coins"></i>
                    <span id="score-display">10</span>
                </div>
                <div class="text-xs text-slate-300 mt-1">Cost bloc: 1 punct</div>
            </div>

            <!-- Right: Tools & Quiz -->
            <div class="flex flex-col items-end gap-2 ml-4">
                <button onclick="openQuizModal()" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 transition-all flex items-center gap-2 animate-pulse mb-2">
                    <i class="fas fa-brain"></i>
                    Câștigă Puncte
                </button>

                <div class="flex gap-2 bg-slate-800/90 p-2 rounded-xl border-2 border-slate-600 shadow-lg backdrop-blur-sm">
                    <button onclick="setTool('build')" id="tool-build" class="tool-btn active bg-slate-700 text-white p-3 rounded-lg font-bold flex items-center gap-2 transition-all hover:bg-slate-600" title="Mod Construire (Click Stânga)">
                        <i class="fas fa-hammer"></i>
                    </button>
                    <button onclick="setTool('destroy')" id="tool-destroy" class="tool-btn bg-slate-700 text-white p-3 rounded-lg font-bold flex items-center gap-2 transition-all hover:bg-red-900/50 hover:text-red-200" title="Mod Demolare (Click Stânga)">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Instructions Helper -->
        <div class="absolute top-32 right-4 bg-black/50 text-white p-2 rounded text-xs text-right backdrop-blur-sm">
            <b>SHIFT + Click:</b> Acțiune (Build/Delete)<br>
            <b>Click + Drag:</b> Rotește Camera<br>
            <b>Scroll:</b> Zoom<br>
            <b>W, A, S, D:</b> Mișcă Camera<br>
            <b>Q, E:</b> Sus / Jos<br>
            <span class="text-yellow-400">Pont: Folosește butoanele de sus<br>pentru a schimba modul!</span>
        </div>

        <!-- Footer: Block Selector -->
        <div class="flex justify-center items-end mb-4 interactive-ui relative">
            <div class="bg-slate-900/80 p-3 rounded-2xl border border-slate-700 flex gap-3 backdrop-blur-md shadow-2xl">
                <!-- Blocks generated via JS. Note: bg-colors removed to rely on texture images -->
                <button onclick="selectBlock('grass')" id="btn-grass" class="block-btn w-12 h-12 rounded-lg border-2 border-transparent hover:scale-105 transition-all relative" title="Iarbă"></button>
                <button onclick="selectBlock('stone')" id="btn-stone" class="block-btn w-12 h-12 rounded-lg border-2 border-transparent hover:scale-105 transition-all relative" title="Piatră"></button>
                <button onclick="selectBlock('dirt')" id="btn-dirt" class="block-btn w-12 h-12 rounded-lg border-2 border-transparent hover:scale-105 transition-all relative" title="Pământ"></button>
                <button onclick="selectBlock('wood')" id="btn-wood" class="block-btn w-12 h-12 rounded-lg border-2 border-transparent hover:scale-105 transition-all relative" title="Lemn"></button>
                <button onclick="selectBlock('brick')" id="btn-brick" class="block-btn w-12 h-12 rounded-lg border-2 border-transparent hover:scale-105 transition-all relative" title="Cărămidă"></button>
                <button onclick="selectBlock('glass')" id="btn-glass" class="block-btn w-12 h-12 rounded-lg border-2 border-transparent hover:scale-105 transition-all relative" title="Sticlă"></button>
            </div>
            
            <!-- Reset Camera Button (Bottom Right) -->
            <button onclick="resetCamera()" class="absolute right-4 bottom-2 bg-slate-700 hover:bg-slate-600 text-white p-3 rounded-full shadow-lg border-2 border-slate-500 transition-all" title="Resetează Camera">
                <i class="fas fa-video"></i>
            </button>
        </div>
    </div>

    <!-- Save Manager Modal -->
    <div id="save-manager-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="bg-white rounded-2xl w-full max-w-lg mx-4 shadow-2xl overflow-hidden flex flex-col max-h-[80vh]">
            <div class="bg-slate-800 p-6 flex justify-between items-center text-white">
                <h2 class="text-xl font-bold"><i class="fas fa-save mr-2"></i>Manager Jocuri</h2>
                <button onclick="closeSaveManager()" class="text-slate-400 hover:text-white transition-colors">
                    <i class="fas fa-times text-2xl"></i>
                </button>
            </div>
            
            <div class="p-6 flex-1 overflow-y-auto">
                <button onclick="createNewGame()" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 px-4 rounded-xl font-bold shadow-md flex items-center justify-center gap-2 mb-6 transition-all">
                    <i class="fas fa-plus-circle"></i> Creează Joc Nou
                </button>

                <h3 class="text-sm font-bold text-slate-500 uppercase tracking-wider mb-3">Jocuri Salvate</h3>
                <div id="save-list" class="flex flex-col gap-3">
                    <!-- Save items injected here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quiz-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="bg-white rounded-2xl w-full max-w-2xl mx-4 shadow-2xl overflow-hidden flex flex-col max-h-[90vh] relative">
            
            <!-- Loading Overlay -->
            <div id="loading-overlay" class="hidden absolute inset-0 bg-white/90 z-20 flex flex-col items-center justify-center">
                <div class="loader mb-4"></div>
                <p class="text-indigo-600 font-bold animate-pulse">Inteligența Artificială gândește... ✨</p>
            </div>

            <!-- Header -->
            <div class="bg-indigo-600 p-6 flex justify-between items-center text-white">
                <div>
                    <h2 class="text-2xl font-bold"><i class="fas fa-graduation-cap mr-2"></i>Centrul de Cunoștințe</h2>
                    <p class="text-indigo-200 text-sm">Demonstrează ce știi și câștigă resurse!</p>
                </div>
                <button onclick="closeQuizModal()" class="text-indigo-200 hover:text-white transition-colors">
                    <i class="fas fa-times text-2xl"></i>
                </button>
            </div>

            <!-- Category Selection -->
            <div id="category-selection" class="p-8 flex flex-col">
                <!-- AI Toggle -->
                <div class="flex justify-center mb-6">
                    <label class="flex items-center gap-3 cursor-pointer bg-indigo-50 px-4 py-2 rounded-full border border-indigo-100 hover:bg-indigo-100 transition-colors">
                        <input type="checkbox" id="ai-toggle" class="w-5 h-5 text-indigo-600 rounded focus:ring-indigo-500">
                        <span class="font-bold text-indigo-700 flex items-center gap-2">
                            <i class="fas fa-magic"></i> Activează Întrebări AI ✨
                        </span>
                    </label>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <button onclick="selectCategory('math')" class="flex flex-col items-center p-6 bg-blue-50 hover:bg-blue-100 rounded-xl border-2 border-blue-200 transition-all hover:-translate-y-1">
                        <div class="w-16 h-16 bg-blue-500 rounded-full flex items-center justify-center text-white text-2xl mb-4 shadow-lg">
                            <i class="fas fa-calculator"></i>
                        </div>
                        <h3 class="font-bold text-gray-700">Matematică</h3>
                        <p class="text-xs text-gray-500 text-center mt-2">Ecuații, Fracții, Procente</p>
                    </button>

                    <button onclick="selectCategory('physics')" class="flex flex-col items-center p-6 bg-purple-50 hover:bg-purple-100 rounded-xl border-2 border-purple-200 transition-all hover:-translate-y-1">
                        <div class="w-16 h-16 bg-purple-500 rounded-full flex items-center justify-center text-white text-2xl mb-4 shadow-lg">
                            <i class="fas fa-atom"></i>
                        </div>
                        <h3 class="font-bold text-gray-700">Fizică</h3>
                        <p class="text-xs text-gray-500 text-center mt-2">Forțe, Unități, Fenomene</p>
                    </button>

                    <button onclick="selectCategory('logic')" class="flex flex-col items-center p-6 bg-emerald-50 hover:bg-emerald-100 rounded-xl border-2 border-emerald-200 transition-all hover:-translate-y-1">
                        <div class="w-16 h-16 bg-emerald-500 rounded-full flex items-center justify-center text-white text-2xl mb-4 shadow-lg">
                            <i class="fas fa-puzzle-piece"></i>
                        </div>
                        <h3 class="font-bold text-gray-700">Logică</h3>
                        <p class="text-xs text-gray-500 text-center mt-2">Deducție, Serii, Perspicacitate</p>
                    </button>
                </div>
            </div>

            <!-- Difficulty Selection (New) -->
            <div id="difficulty-selection" class="hidden p-8 flex-col items-center">
                <h3 class="text-xl font-bold text-gray-700 mb-6">Alege Nivelul de Dificultate</h3>
                <div class="grid grid-cols-1 gap-4 w-full max-w-md">
                    <button onclick="selectDifficulty('easy')" class="p-4 bg-green-100 hover:bg-green-200 text-green-800 rounded-xl border-2 border-green-300 font-bold flex justify-between items-center transition-all hover:scale-105">
                        <span class="flex items-center gap-2"><i class="fas fa-seedling"></i> Ușor</span>
                        <span class="bg-white px-3 py-1 rounded-full text-sm font-black shadow-sm text-green-600">+1 Punct</span>
                    </button>
                    <button onclick="selectDifficulty('medium')" class="p-4 bg-yellow-100 hover:bg-yellow-200 text-yellow-800 rounded-xl border-2 border-yellow-300 font-bold flex justify-between items-center transition-all hover:scale-105">
                        <span class="flex items-center gap-2"><i class="fas fa-layer-group"></i> Mediu</span>
                        <span class="bg-white px-3 py-1 rounded-full text-sm font-black shadow-sm text-yellow-600">+3 Puncte</span>
                    </button>
                    <button onclick="selectDifficulty('hard')" class="p-4 bg-red-100 hover:bg-red-200 text-red-800 rounded-xl border-2 border-red-300 font-bold flex justify-between items-center transition-all hover:scale-105">
                        <span class="flex items-center gap-2"><i class="fas fa-fire"></i> Complex</span>
                        <span class="bg-white px-3 py-1 rounded-full text-sm font-black shadow-sm text-red-600">+10 Puncte</span>
                    </button>
                </div>
                <button onclick="resetToCategories()" class="mt-6 text-indigo-600 hover:text-indigo-800 font-medium underline">
                    <i class="fas fa-arrow-left mr-1"></i> Înapoi la Categorii
                </button>
            </div>

            <!-- Question View -->
            <div id="question-view" class="hidden p-8 flex-col">
                <div class="flex justify-between items-center mb-2">
                    <div class="text-sm font-bold text-indigo-600 uppercase tracking-wide" id="q-category">CATEGORIE</div>
                    <div class="text-xs font-bold px-2 py-1 rounded text-white uppercase tracking-wide" id="q-difficulty-badge">DIFFICULTY</div>
                </div>
                <h3 class="text-xl font-medium text-gray-800 mb-6" id="q-text">Întrebarea va apărea aici...</h3>
                
                <div class="grid grid-cols-1 gap-3" id="answers-container">
                    <!-- Answer buttons injected here -->
                </div>
            </div>

            <!-- Feedback View -->
            <div id="feedback-view" class="hidden p-8 flex-col items-center text-center overflow-y-auto">
                <div id="feedback-icon" class="text-6xl mb-4"></div>
                <h3 id="feedback-title" class="text-2xl font-bold mb-2"></h3>
                <p id="feedback-message" class="text-gray-600 mb-4"></p>
                
                <!-- AI Explanation Section -->
                <div id="ai-explanation-container" class="w-full mb-6 hidden">
                    <div id="ai-explanation-text" class="bg-indigo-50 border border-indigo-100 p-4 rounded-lg text-left text-sm text-indigo-800 leading-relaxed italic">
                        <!-- AI text goes here -->
                    </div>
                </div>

                <div class="flex gap-3 justify-center w-full flex-wrap">
                    <button onclick="askAIExplanation()" id="btn-explain-ai" class="bg-indigo-100 hover:bg-indigo-200 text-indigo-700 px-6 py-2 rounded-lg font-bold flex items-center gap-2 transition-colors">
                        <i class="fas fa-magic"></i> Explică-mi ✨
                    </button>
                    <button onclick="nextQuestion()" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 font-bold shadow-md transition-all hover:scale-105">
                        <i class="fas fa-arrow-right mr-2"></i> Continuă
                    </button>
                    <button onclick="closeQuizModal()" class="bg-gray-500 text-white px-6 py-2 rounded-lg hover:bg-gray-600 font-bold shadow-md transition-all hover:scale-105">
                        <i class="fas fa-times mr-2"></i> Închide
                    </button>
                </div>
            </div>

        </div>
    </div>

    <!-- Notification Toast -->
    <div id="toast" class="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-6 py-3 rounded-full shadow-xl translate-y-20 opacity-0 transition-all duration-300 font-bold z-50">
        Nu ai suficiente puncte!
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        /**
         * ------------------------------------------------------------------
         * GLOBAL DEFINITIONS & CONFIG
         * ------------------------------------------------------------------
         */
        var apiKey = ""; // Set by environment
        var API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        var currentActiveQuestion = null;
        var currentCategory = null;
        var currentDifficulty = null;
        
        // New Hierarchical Database Structure
        var database = { 
            math: { easy: [], medium: [], hard: [] }, 
            physics: { easy: [], medium: [], hard: [] }, 
            logic: { easy: [], medium: [], hard: [] } 
        };
        
        // 3D Globals
        var camera, scene, renderer, controls;
        var plane, raycaster, mouse = new THREE.Vector2();
        var isShiftDown = false;
        var rollOverMesh, rollOverMaterial;
        var objects = [];
        var materials = {};
        var isDragging = false;
        var startMousePos = {x: 0, y: 0};
        var keysPressed = {};
        
        // Game State
        const META_KEY = 'md_builder_meta';
        const SAVE_PREFIX = 'md_builder_data_';
        // Old key for migration
        const OLD_GAME_STATE_KEY = 'md_builder_save_v2';

        var currentSaveId = null;
        var state = { points: 10, blocks: [] };
        var activeTool = 'build';
        var currentBlockType = 'grass';

        // Utilities
        function rInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function shuffle(array) { return array.sort(() => Math.random() - 0.5); }
        function gcd(a, b) { return b == 0 ? a : gcd(b, a % b); }

        /**
         * ------------------------------------------------------------------
         * SAVE SYSTEM
         * ------------------------------------------------------------------
         */
        function initSaveSystem() {
            // 1. Check migration
            const oldData = localStorage.getItem(OLD_GAME_STATE_KEY);
            let meta = getMeta();

            if (oldData && meta.saves.length === 0) {
                // Migrate old save to new system
                const newId = 'save_' + Date.now();
                const saveData = JSON.parse(oldData);
                saveGameData(newId, saveData);
                
                meta.saves.push({ id: newId, name: 'Joc Migrat', date: new Date().toLocaleString() });
                meta.lastPlayed = newId;
                localStorage.setItem(META_KEY, JSON.stringify(meta));
                localStorage.removeItem(OLD_GAME_STATE_KEY); // Clean up
                console.log("Migrated legacy save.");
            }

            // 2. Load last played or create new
            if (meta.lastPlayed && localStorage.getItem(SAVE_PREFIX + meta.lastPlayed)) {
                loadGame(meta.lastPlayed);
            } else if (meta.saves.length > 0) {
                loadGame(meta.saves[0].id);
            } else {
                createNewGame();
            }
        }

        function getMeta() {
            const raw = localStorage.getItem(META_KEY);
            return raw ? JSON.parse(raw) : { saves: [], lastPlayed: null };
        }

        function saveGameData(id, data) {
            localStorage.setItem(SAVE_PREFIX + id, JSON.stringify(data));
        }

        function createNewGame() {
            const id = 'save_' + Date.now();
            const name = `Joc ${getMeta().saves.length + 1}`;
            
            // Init Empty State
            state = { points: 10, blocks: [] };
            currentSaveId = id;
            
            // Update Meta
            const meta = getMeta();
            meta.saves.push({ id: id, name: name, date: new Date().toLocaleString() });
            meta.lastPlayed = id;
            localStorage.setItem(META_KEY, JSON.stringify(meta));
            
            // Save Initial Data
            saveState();
            
            // Refresh UI
            updateGameUI();
            if(scene) rebuildWorld(); // Clear board
            closeSaveManager();
            showToast("Joc nou creat!");
        }

        function loadGame(id) {
            const raw = localStorage.getItem(SAVE_PREFIX + id);
            if (raw) {
                state = JSON.parse(raw);
                currentSaveId = id;
                
                // Update last played
                const meta = getMeta();
                meta.lastPlayed = id;
                localStorage.setItem(META_KEY, JSON.stringify(meta));

                updateGameUI();
                if(scene) rebuildWorld();
                closeSaveManager();
                showToast("Joc încărcat!");
            }
        }

        function deleteGame(id) {
            if(confirm("Sigur vrei să ștergi acest joc? Nu se poate anula.")) {
                // Remove data
                localStorage.removeItem(SAVE_PREFIX + id);
                
                // Update Meta
                const meta = getMeta();
                meta.saves = meta.saves.filter(s => s.id !== id);
                if (meta.lastPlayed === id) meta.lastPlayed = null;
                localStorage.setItem(META_KEY, JSON.stringify(meta));

                // If deleted current game, switch or create new
                if (currentSaveId === id) {
                    if (meta.saves.length > 0) loadGame(meta.saves[0].id);
                    else createNewGame();
                } else {
                    renderSaveList(); // Refresh list only
                }
            }
        }

        function saveState() {
            if (!currentSaveId) return;
            localStorage.setItem(SAVE_PREFIX + currentSaveId, JSON.stringify(state));
            
            // Update timestamp in meta
            const meta = getMeta();
            const saveInfo = meta.saves.find(s => s.id === currentSaveId);
            if(saveInfo) {
                saveInfo.date = new Date().toLocaleString();
                localStorage.setItem(META_KEY, JSON.stringify(meta));
            }
            
            updateUI();
        }

        function updateGameUI() {
            const meta = getMeta();
            const saveInfo = meta.saves.find(s => s.id === currentSaveId);
            if (saveInfo) {
                document.getElementById('current-game-name').innerText = saveInfo.name;
            }
            updateUI();
        }

        // UI Manager Functions
        function openSaveManager() {
            document.getElementById('save-manager-modal').classList.remove('hidden');
            renderSaveList();
        }

        function closeSaveManager() {
            document.getElementById('save-manager-modal').classList.add('hidden');
        }

        function renderSaveList() {
            const list = document.getElementById('save-list');
            list.innerHTML = '';
            const meta = getMeta();

            meta.saves.forEach(save => {
                const isActive = save.id === currentSaveId;
                const item = document.createElement('div');
                item.className = `flex items-center justify-between p-3 rounded-lg border-2 ${isActive ? 'bg-blue-50 border-blue-500' : 'bg-slate-50 border-slate-200'}`;
                item.innerHTML = `
                    <div class="flex flex-col">
                        <span class="font-bold text-slate-700">${save.name} ${isActive ? '(Activ)' : ''}</span>
                        <span class="text-xs text-slate-500">${save.date}</span>
                    </div>
                    <div class="flex gap-2">
                        ${!isActive ? `<button onclick="loadGame('${save.id}')" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 text-sm">Încarcă</button>` : ''}
                        <button onclick="deleteGame('${save.id}')" class="text-red-500 hover:bg-red-50 px-2 py-1 rounded transition-colors"><i class="fas fa-trash"></i></button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        /**
         * ------------------------------------------------------------------
         * DATA GENERATION - ADVANCED
         * ------------------------------------------------------------------
         */
        function finalizeQs(list) {
            return list.map(item => {
                const correctVal = item.a[0];
                const shuffledA = shuffle([...item.a]);
                return { q: item.q, a: shuffledA, c: shuffledA.indexOf(correctVal) };
            });
        }

        function generateMathQs(count) {
            let easy = [], medium = [], hard = [];
            
            for(let i=0; i<count; i++) {
                // --- EASY (Arithmetic, Order Ops, Perimeter) ---
                let a = rInt(2, 20), b = rInt(2, 20);
                // 1. Addition
                easy.push({ q: `Calculați: ${a} + ${b}`, a: [`${a+b}`, `${a+b+2}`, `${a+b-1}`, `${a+b+10}`], c:0 });
                // 2. Order of operations simple
                let c = rInt(2,5);
                easy.push({ q: `Calculați: ${a} + ${b} × ${c}`, a: [`${a + b*c}`, `${(a+b)*c}`, `${a + b*c + 2}`, `${a*c + b}`], c:0 });
                // 3. Perimeter Square
                easy.push({ q: `Perimetrul unui pătrat cu latura ${a} cm este:`, a: [`${4*a} cm`, `${a*a} cm`, `${2*a} cm`, `${a+4} cm`], c:0 });
                
                // --- MEDIUM (Linear Eq simple, Fractions, Percent) ---
                // 4. Linear Eq ax = b
                let x = rInt(2,12), m = rInt(2,9), res = m*x;
                medium.push({ q: `Rezolvă: ${m}x = ${res}`, a: [`${x}`, `${x+1}`, `${x-1}`, `${x*2}`], c:0 });
                // 5. Fraction Addition (Same Denom)
                let d = rInt(2, 10), n1 = rInt(1, d-1), n2 = rInt(1, d-1);
                medium.push({ q: `Calculați: ${n1}/${d} + ${n2}/${d}`, a: [`${n1+n2}/${d}`, `${n1+n2}/${d+d}`, `${Math.abs(n1-n2)}/${d}`, `1`], c:0 });
                // 6. Percentage
                let p = rInt(1, 9) * 10, val = rInt(2, 20) * 10;
                medium.push({ q: `Cât este ${p}% din ${val}?`, a: [`${(p*val)/100}`, `${(p*val)/10}`, `${val/2}`, `${p+val}`], c:0 });
                // 7. Integer + Fraction
                medium.push({ q: `Calculați: 1 + 1/${a}`, a: [`${a+1}/${a}`, `${a}/${a+1}`, `1/${a}`, `${a-1}/${a}`], c:0 });

                // --- HARD (Linear Eq mixed, Powers, Comparison) ---
                // 8. Linear Eq ax + b = c (mixed signs)
                let xH = rInt(-5, 5), aH = rInt(2, 5) * (Math.random()<.5?1:-1), bH = rInt(1, 10) * (Math.random()<.5?1:-1);
                let cH = aH * xH + bH;
                let sign = bH < 0 ? '-' : '+';
                hard.push({ q: `Rezolvă: ${aH}x ${sign} ${Math.abs(bH)} = ${cH}`, a: [`${xH}`, `${-xH}`, `${xH+1}`, `${0}`], c:0 });
                // 9. Powers
                hard.push({ q: `Calculați: (-${c})³`, a: [`${-c*c*c}`, `${c*c*c}`, `${-3*c}`, `${c+3}`], c:0 });
                // 10. Comparison fractions
                let num = rInt(1, 5);
                hard.push({ q: `Compară: ${num}/2 și ${num}/3`, a: [`${num}/2 > ${num}/3`, `${num}/2 < ${num}/3`, `Egale`, `Nu se poate`], c:0 });
            }
            return { easy: finalizeQs(easy), medium: finalizeQs(medium), hard: finalizeQs(hard) };
        }

        function generatePhysicsQs(count) {
            let easy = [], medium = [], hard = [];
            
            const units = [
                {name: "Forța", u: "Newton (N)"}, {name: "Masa", u: "Kilogram (kg)"}, {name: "Timpul", u: "Secunda (s)"},
                {name: "Lungimea", u: "Metrul (m)"}, {name: "Viteza", u: "m/s"}, {name: "Densitatea", u: "kg/m³"}
            ];

            for(let i=0; i<count; i++) {
                // --- EASY (Units, Definitions, Basic Weight) ---
                // 1. Unit Identification
                let uObj = units[rInt(0, units.length-1)];
                easy.push({ q: `Unitatea de măsură pentru ${uObj.name} este:`, a: [`${uObj.u}`, `Pascal (Pa)`, `Joule (J)`, `Watt (W)`], c:0 });
                // 2. Force Definition
                easy.push({ q: `Forța este o mărime fizică:`, a: [`Vectorială`, `Scalară`, `Fundamentală`, `Adimensională`], c:0 });
                // 3. Simple Weight
                let m = rInt(1,10);
                easy.push({ q: `Greutatea unui corp de ${m}kg (g=10N/kg) este:`, a: [`${m*10}N`, `${m}N`, `${m/10}N`, `${m+10}N`], c:0 });

                // --- MEDIUM (Formulas, Velocity, Density) ---
                // 4. Formula Match
                let forms = [
                    {n: "Greutate", f: "G = m · g"}, {n: "Viteză", f: "v = d / t"}, 
                    {n: "Densitate", f: "ρ = m / V"}, {n: "Presiune", f: "p = F / S"}
                ];
                let fObj = forms[rInt(0, forms.length-1)];
                medium.push({ q: `Formula pentru ${fObj.n} este:`, a: [`${fObj.f}`, `F = m · a`, `L = F · d`, `E = m · c²`], c:0 });
                // 5. Velocity Calc
                let v = rInt(2, 20), t = rInt(2, 10), d = v * t;
                medium.push({ q: `Dacă d=${d}m și t=${t}s, viteza este:`, a: [`${v} m/s`, `${d} m/s`, `${v*2} m/s`, `${t} m/s`], c:0 });
                // 6. Density Calc
                let rho = rInt(2, 8)*100, V = rInt(2,5), mass = rho*V;
                medium.push({ q: `Aflați ρ dacă m=${mass}kg și V=${V}m³:`, a: [`${rho} kg/m³`, `${mass} kg/m³`, `${rho/10} kg/m³`, `${V*100} kg/m³`], c:0 });
                // 7. Unit Conversion Simple
                let km = rInt(1, 10);
                medium.push({ q: `${km} km în metri înseamnă:`, a: [`${km*1000} m`, `${km*100} m`, `${km*10} m`, `${km/1000} m`], c:0 });

                // --- HARD (Pressure, Work, Complex Conversion) ---
                // 8. Pressure Calc
                let F = rInt(10, 100), S = rInt(2, 5), p = F/S; // Integers preferably? Let's force F to be multiple
                F = p * S * 10; // Ensure scale
                p = F / S;
                hard.push({ q: `Calculați presiunea dacă F=${F}N și S=${S}m²:`, a: [`${p} Pa`, `${F} Pa`, `${S} Pa`, `${p*10} Pa`], c:0 });
                // 9. Mechanical Work
                let Fw = rInt(5, 20), dw = rInt(2, 10);
                hard.push({ q: `Lucrul mecanic (L=F·d) pentru F=${Fw}N, d=${dw}m:`, a: [`${Fw*dw} J`, `${Fw} J`, `${Fw+dw} J`, `${Fw/dw} J`], c:0 });
                // 10. Velocity Conversion
                let ms = rInt(5, 25); // m/s
                let kmh = ms * 3.6;
                hard.push({ q: `Transformați ${ms} m/s în km/h:`, a: [`${kmh} km/h`, `${ms} km/h`, `${ms*10} km/h`, `${ms/3.6} km/h`], c:0 });
            }
            return { easy: finalizeQs(easy), medium: finalizeQs(medium), hard: finalizeQs(hard) };
        }

        function generateLogicQs(count) {
            let easy = [], medium = [], hard = [];
            const days = ["Luni", "Marți", "Miercuri", "Joi", "Vineri", "Sâmbătă", "Duminică"];
            
            for(let i=0; i<count; i++) {
                // --- EASY ---
                // 1. Days
                let start = rInt(0, 6), off = rInt(1, 3), end = (start + off) % 7;
                easy.push({ q: `Azi e ${days[start]}. Ce zi va fi peste ${off} zile?`, a: [`${days[end]}`, `${days[(end+1)%7]}`, `${days[(end+2)%7]}`, `${days[(end-1+7)%7]}`], c:0 });
                // 2. Odd One Out (Numbers)
                easy.push({ q: `Care număr nu se potrivește: 2, 4, 6, 9, 8?`, a: [`9`, `2`, `6`, `8`], c:0 });
                // 3. Simple Dice
                easy.push({ q: `Care este șansa să dai 7 cu un singur zar normal?`, a: [`0%`, `50%`, `16%`, `100%`], c:0 });

                // --- MEDIUM ---
                // 4. Series +N
                let s1 = rInt(1,10), step = rInt(2,5);
                medium.push({ q: `Continuă: ${s1}, ${s1+step}, ${s1+step*2}, ...`, a: [`${s1+step*3}`, `${s1+step*3+1}`, `${s1+step*3-1}`, `${s1+step*4}`], c:0 });
                // 5. Clock Math
                let h = rInt(1, 10);
                medium.push({ q: `Acum e ora ${h}:00. Peste 90 minute va fi:`, a: [`${h+1}:30`, `${h+2}:00`, `${h+1}:00`, `${h}:90`], c:0 });
                // 6. Directions
                medium.push({ q: `Ești cu fața la Nord. Te întorci la dreapta de 2 ori. Unde privești?`, a: [`Sud`, `Est`, `Vest`, `Nord`], c:0 });
                // 7. Family Logic
                medium.push({ q: `Fratele tatălui tău este:`, a: [`Unchiul`, `Bunicul`, `Vărul`, `Nepotul`], c:0 });

                // --- HARD ---
                // 8. Series *N
                let s2 = rInt(2,5), m = 2;
                hard.push({ q: `Urmează: ${s2}, ${s2*m}, ${s2*m*m}, ...`, a: [`${s2*m*m*m}`, `${s2*m*m+1}`, `${s2*m*3}`, `${s2+10}`], c:0 });
                // 9. Age Problem
                let myAge = rInt(10, 20);
                hard.push({ q: `Eu am ${myAge} ani. Sora mea are jumătate. Peste 5 ani sora va avea:`, a: [`${(myAge/2)+5}`, `${myAge/2}`, `${myAge+5}`, `${(myAge+5)/2}`], c:0 });
                // 10. Anagrams (Simple School words)
                let words = [
                    {s: "ELVE", c: "ELEV"}, {s: "TECAI", c: "CAIET"}, {s: "LOASAC", c: "SCOALA"}
                ];
                let w = words[rInt(0, words.length-1)];
                hard.push({ q: `Ce cuvânt este amestecat aici: "${w.s}"?`, a: [`${w.c}`, `MASA`, `CARTE`, `PIX`], c:0 });
            }
            return { easy: finalizeQs(easy), medium: finalizeQs(medium), hard: finalizeQs(hard) };
        }

        function initQuestions() {
            // 1. Generate Procedural Data (Add 50 of each type/level for variety)
            const count = 50;
            
            const mathGen = generateMathQs(count);
            database.math.easy = shuffle(mathGen.easy);
            database.math.medium = shuffle(mathGen.medium);
            database.math.hard = shuffle(mathGen.hard);

            const physGen = generatePhysicsQs(count);
            database.physics.easy = shuffle(physGen.easy);
            database.physics.medium = shuffle(physGen.medium);
            database.physics.hard = shuffle(physGen.hard);

            const logicGen = generateLogicQs(count);
            database.logic.easy = shuffle(logicGen.easy);
            database.logic.medium = shuffle(logicGen.medium);
            database.logic.hard = shuffle(logicGen.hard);

            console.log("Database initialized with dynamic content.");
        }

        /**
         * ------------------------------------------------------------------
         * GEMINI & QUIZ FUNCTIONS
         * ------------------------------------------------------------------
         */
        async function callGemini(prompt, isJson = false) {
            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            if (isJson) payload.generationConfig = { responseMimeType: "application/json" };
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error('API Error');
                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                console.error("Gemini API Error:", error);
                throw error;
            }
        }

        async function generateAIQuestion(category, difficulty) {
            const categoryMap = { math: 'Matematică', physics: 'Fizică', logic: 'Logică' };
            const difficultyMap = { easy: 'Ușor (cunoștințe de bază)', medium: 'Mediu (aplicare formule simple)', hard: 'Complex (probleme de logică sau multi-pas)' };
            
            const catName = categoryMap[category];
            const diffName = difficultyMap[difficulty];

            const prompt = `Ești un profesor expert pentru clasa a 7-a în Republica Moldova. 
            Generează o întrebare grilă unică din categoria "${catName}" cu nivelul de dificultate "${diffName}".
            Returnează DOAR un JSON valid cu acest format strict:
            { "q": "textul întrebării aici", "a": ["varianta 1", "varianta 2", "varianta 3", "varianta 4"], "c": indexul_corect_0_la_3_integer }`;
            
            const jsonText = await callGemini(prompt, true);
            return JSON.parse(jsonText);
        }

        async function askAIExplanation() {
            if (!currentActiveQuestion) return;
            const btn = document.getElementById('btn-explain-ai');
            const container = document.getElementById('ai-explanation-container');
            const textBox = document.getElementById('ai-explanation-text');
            btn.innerHTML = '<div class="loader w-4 h-4 border-2 mr-2"></div> Gândesc...';
            btn.disabled = true;
            const correctAns = currentActiveQuestion.a[currentActiveQuestion.c];
            const prompt = `Explică pe scurt (maxim 2-3 fraze), pe înțelesul unui elev de 13 ani, de ce răspunsul corect la întrebarea "${currentActiveQuestion.q}" este "${correctAns}". Fii încurajator și educativ. Limba: Română.`;
            try {
                const explanation = await callGemini(prompt, false);
                textBox.innerText = explanation;
                container.classList.remove('hidden');
                btn.classList.add('hidden');
            } catch (error) {
                showToast("Eroare la conectarea cu AI-ul.", true);
                btn.innerHTML = '<i class="fas fa-magic"></i> Încearcă din nou ✨';
                btn.disabled = false;
            }
        }

        // UI Functions
        function openQuizModal() {
            document.getElementById('quiz-modal').classList.remove('hidden');
            resetToCategories();
        }

        function closeQuizModal() {
            document.getElementById('quiz-modal').classList.add('hidden');
        }

        function resetToCategories() {
            // Views
            document.getElementById('category-selection').classList.remove('hidden');
            document.getElementById('category-selection').classList.add('flex');
            document.getElementById('difficulty-selection').classList.add('hidden');
            document.getElementById('difficulty-selection').classList.remove('flex');
            document.getElementById('question-view').classList.add('hidden');
            document.getElementById('question-view').classList.remove('flex');
            document.getElementById('feedback-view').classList.add('hidden');
            document.getElementById('feedback-view').classList.remove('flex');
            
            // Components
            document.getElementById('ai-explanation-container').classList.add('hidden');
            const expBtn = document.getElementById('btn-explain-ai');
            expBtn.classList.remove('hidden');
            expBtn.innerHTML = '<i class="fas fa-magic"></i> Explică-mi ✨';
            expBtn.disabled = false;
        }

        function selectCategory(category) {
            currentCategory = category;
            document.getElementById('category-selection').classList.add('hidden');
            document.getElementById('category-selection').classList.remove('flex');
            
            document.getElementById('difficulty-selection').classList.remove('hidden');
            document.getElementById('difficulty-selection').classList.add('flex');
        }

        async function selectDifficulty(difficulty) {
            currentDifficulty = difficulty;
            document.getElementById('difficulty-selection').classList.add('hidden');
            document.getElementById('difficulty-selection').classList.remove('flex');
            
            await loadNextQuestion();
        }

        async function loadNextQuestion() {
            // Reset Feedback/Explanation UI first
            document.getElementById('feedback-view').classList.add('hidden');
            document.getElementById('feedback-view').classList.remove('flex');
            document.getElementById('ai-explanation-container').classList.add('hidden');
            const expBtn = document.getElementById('btn-explain-ai');
            expBtn.classList.remove('hidden');
            expBtn.innerHTML = '<i class="fas fa-magic"></i> Explică-mi ✨';
            expBtn.disabled = false;

            const useAI = document.getElementById('ai-toggle').checked;

            if (useAI) {
                document.getElementById('loading-overlay').classList.remove('hidden');
                try {
                    const qData = await generateAIQuestion(currentCategory, currentDifficulty);
                    displayQuestion(qData);
                } catch (error) {
                    showToast("Eroare AI. Folosim baza de date locală.", true);
                    fetchFromDatabase(currentCategory, currentDifficulty);
                } finally {
                    document.getElementById('loading-overlay').classList.add('hidden');
                }
            } else {
                fetchFromDatabase(currentCategory, currentDifficulty);
            }
        }

        // Alias for the "Continuă" button
        function nextQuestion() {
            loadNextQuestion();
        }

        function fetchFromDatabase(cat, diff) {
            let pool = database[cat][diff];

            // Check for exhaustion and REGENERATE automatically
            if (!pool || pool.length === 0) { 
                console.log(`Pool empty for ${cat} - ${diff}. Regenerating...`);
                
                let newQsObj;
                const count = 10;

                if (cat === 'math') newQsObj = generateMathQs(count);
                else if (cat === 'physics') newQsObj = generatePhysicsQs(count);
                else if (cat === 'logic') newQsObj = generateLogicQs(count); // Now we have Logic generator!

                if (newQsObj && newQsObj[diff] && newQsObj[diff].length > 0) {
                    database[cat][diff] = shuffle(newQsObj[diff]);
                    pool = database[cat][diff];
                    showToast("S-au generat întrebări noi!", false);
                } else {
                    showToast("Nu mai sunt întrebări. Încearcă altă categorie.", true); 
                    resetToCategories();
                    return; 
                }
            }

            // Pick random index
            const index = Math.floor(Math.random() * pool.length);
            const qData = pool[index];
            
            // REMOVE from pool immediately so it's not asked again until regen
            pool.splice(index, 1);

            displayQuestion(qData);
        }

        function displayQuestion(qData) {
            currentActiveQuestion = qData;
            const qView = document.getElementById('question-view');
            qView.classList.remove('hidden');
            qView.classList.add('flex');
            
            const catNames = { math: 'Matematică', physics: 'Fizică', logic: 'Logică' };
            const diffStyles = { 
                easy: 'bg-green-500', 
                medium: 'bg-yellow-500', 
                hard: 'bg-red-500' 
            };
            const diffNames = { easy: 'Ușor', medium: 'Mediu', hard: 'Complex' };

            document.getElementById('q-category').innerText = catNames[currentCategory];
            const badge = document.getElementById('q-difficulty-badge');
            badge.className = `text-xs font-bold px-2 py-1 rounded text-white uppercase tracking-wide ${diffStyles[currentDifficulty]}`;
            badge.innerText = diffNames[currentDifficulty];

            document.getElementById('q-text').innerText = qData.q;
            
            const ansContainer = document.getElementById('answers-container');
            ansContainer.innerHTML = '';
            qData.a.forEach((ansText, index) => {
                const btn = document.createElement('button');
                btn.className = "w-full text-left p-4 rounded-lg border-2 border-gray-200 hover:border-indigo-500 hover:bg-indigo-50 transition-all font-medium text-gray-700";
                btn.innerText = `${String.fromCharCode(65 + index)}. ${ansText}`;
                btn.onclick = () => handleAnswer(index, qData.c);
                ansContainer.appendChild(btn);
            });
        }

        function handleAnswer(selectedIndex, correctIndex) {
            const qView = document.getElementById('question-view');
            qView.classList.add('hidden');
            qView.classList.remove('flex');
            
            const fView = document.getElementById('feedback-view');
            fView.classList.remove('hidden');
            fView.classList.add('flex');
            
            const icon = document.getElementById('feedback-icon');
            const title = document.getElementById('feedback-title');
            const msg = document.getElementById('feedback-message');
            
            if (selectedIndex === correctIndex) {
                const pointsMap = { easy: 1, medium: 3, hard: 10 };
                const pts = pointsMap[currentDifficulty];
                
                state.points += pts;
                saveState();
                
                icon.innerHTML = '<i class="fas fa-check-circle text-green-500"></i>';
                title.innerText = "Corect!";
                title.className = "text-2xl font-bold mb-2 text-green-600";
                msg.innerText = `Felicitări! Ai primit ${pts} puncte.`;
                showToast(`+${pts} Puncte!`, false);
            } else {
                icon.innerHTML = '<i class="fas fa-times-circle text-red-500"></i>';
                title.innerText = "Greșit!";
                title.className = "text-2xl font-bold mb-2 text-red-600";
                msg.innerText = "Nu te descuraja! Mai încearcă o dată.";
            }
        }

        /**
         * ------------------------------------------------------------------
         * GAME LOGIC
         * ------------------------------------------------------------------
         */
        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const colors = { grass: '#16a34a', stone: '#64748b', dirt: '#854d0e', wood: '#c2410c', brick: '#991b1b', glass: 'rgba(165, 243, 252, 0.4)' };
            ctx.fillStyle = colors[type] || '#ffffff';
            ctx.fillRect(0, 0, 64, 64);

            if (type === 'brick') {
                ctx.fillStyle = '#7f1d1d'; ctx.fillRect(0, 0, 64, 2); ctx.fillRect(0, 32, 64, 2);
                ctx.fillRect(32, 0, 2, 32); ctx.fillRect(0, 32, 2, 32);
                ctx.fillStyle = 'rgba(0,0,0,0.2)'; for(let i=0; i<10; i++) ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            } 
            else if (type === 'wood') {
                ctx.fillStyle = '#451a03'; ctx.fillRect(0, 0, 64, 64);
                ctx.fillStyle = '#c2410c'; ctx.fillRect(2, 2, 60, 18); ctx.fillRect(2, 22, 60, 18); ctx.fillRect(2, 42, 60, 18);
                ctx.fillStyle = '#451a03'; ctx.fillRect(5, 10, 2, 2); ctx.fillRect(58, 30, 2, 2);
            } 
            else if (type === 'stone') {
                for(let i=0; i<50; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#475569' : '#94a3b8';
                    ctx.fillRect(Math.random()*60, Math.random()*60, Math.random()*10, Math.random()*10);
                }
                ctx.strokeStyle = '#1e293b'; ctx.strokeRect(0,0,64,64);
            } 
            else if (type === 'grass') {
                ctx.fillStyle = '#15803d'; for(let i=0; i<30; i++) { ctx.fillRect(Math.random() * 64, Math.random() * 64, 2, 6); }
                ctx.fillStyle = '#713f12'; for(let i=0; i<10; i++) ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            }
            else if (type === 'dirt') {
                ctx.fillStyle = '#713f12'; for(let i=0; i<40; i++) { ctx.fillRect(Math.random()*60, Math.random()*60, 4, 4); }
            }
            else if (type === 'glass') {
                ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 4; ctx.strokeRect(0,0,64,64);
                ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(10, 10); ctx.lineTo(20, 20); ctx.stroke();
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            return texture;
        }

        const blockTypes = {
            grass: { name: 'Iarbă' }, stone: { name: 'Piatră' }, dirt:  { name: 'Pământ' },
            wood:  { name: 'Lemn' }, brick: { name: 'Cărămidă' }, glass: { name: 'Sticlă', transparent: true, opacity: 0.8 }
        };

        function loadState() {
            // Replaced by initSaveSystem() in window.onload
        }

        function updateUI() {
            document.getElementById('score-display').innerText = state.points;
            document.querySelectorAll('.block-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${currentBlockType}`).classList.add('active');
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`tool-${activeTool}`).classList.add('active');
            if (rollOverMaterial) {
                rollOverMaterial.color.setHex(activeTool === 'destroy' ? 0xff0000 : 0xffffff);
            }
        }

        function selectBlock(type) {
            currentBlockType = type;
            activeTool = 'build';
            if (rollOverMesh && materials[type]) {
                rollOverMesh.material.map = materials[type].map;
                rollOverMesh.material.needsUpdate = true;
            }
            updateUI();
        }

        function setTool(tool) {
            activeTool = tool;
            updateUI();
        }

        function showToast(msg, isError = true) {
            const toast = document.getElementById('toast');
            toast.innerText = msg;
            toast.className = `fixed bottom-24 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-full shadow-xl transition-all duration-300 font-bold z-50 ${isError ? 'bg-red-600 text-white' : 'bg-green-600 text-white'}`;
            toast.classList.remove('translate-y-20', 'opacity-0');
            setTimeout(() => { toast.classList.add('translate-y-20', 'opacity-0'); }, 3000);
        }

        function resetCamera() {
            if (!camera || !controls) return;
            camera.position.set(500, 800, 1300);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function init3D() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f9ff);
                scene.fog = new THREE.Fog(0xf0f9ff, 2000, 5000);

                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.set(500, 800, 1300);
                camera.lookAt(0, 0, 0);

                const gridHelper = new THREE.GridHelper(2000, 40, 0x000000, 0x555555);
                scene.add(gridHelper);

                const groundGeo = new THREE.PlaneGeometry(2000, 2000);
                const groundMat = new THREE.MeshBasicMaterial({ color: 0xe2e8f0, side: THREE.DoubleSide });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -1;
                scene.add(ground);

                const geometry = new THREE.PlaneGeometry(2000, 2000);
                geometry.rotateX(-Math.PI / 2);
                plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ visible: false }));
                scene.add(plane);
                objects.push(plane);

                const ambientLight = new THREE.AmbientLight(0xaaaaaa);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(1, 0.75, 0.5).normalize();
                scene.add(directionalLight);

                for (const [key, data] of Object.entries(blockTypes)) {
                    const texture = createTexture(key);
                    materials[key] = new THREE.MeshLambertMaterial({ 
                        map: texture,
                        transparent: data.transparent || false,
                        opacity: data.opacity || 1
                    });
                    const btn = document.getElementById(`btn-${key}`);
                    if(btn) {
                        const imgData = texture.image.toDataURL();
                        btn.style.backgroundImage = `url(${imgData})`;
                    }
                }

                const rollOverGeo = new THREE.BoxGeometry(50, 50, 50);
                rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
                rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
                scene.add(rollOverMesh);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('game-container').appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; 
                controls.dampingFactor = 0.05;
                controls.update();

                raycaster = new THREE.Raycaster();
                
                document.addEventListener('mousemove', onDocumentMouseMove);
                const canvas = renderer.domElement;
                canvas.addEventListener('pointerdown', onPointerDown);
                canvas.addEventListener('pointerup', onPointerUp);
                document.addEventListener('keydown', onDocumentKeyDown);
                document.addEventListener('keyup', onDocumentKeyUp);
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('contextmenu', (e) => e.preventDefault());

                rebuildWorld();
                selectBlock('grass');
            } catch (error) {
                console.error("Critical 3D Error:", error);
                showToast("Eroare la încărcarea graficii 3D.", true);
            }
        }

        function rebuildWorld() {
            // Clean existing
            objects.forEach(obj => {
                if(obj !== plane) scene.remove(obj);
            });
            objects = [plane];

            state.blocks.forEach(bData => {
                const geo = new THREE.BoxGeometry(50, 50, 50);
                const mat = materials[bData.type];
                const voxel = new THREE.Mesh(geo, mat);
                voxel.position.set(bData.x, bData.y, bData.z);
                voxel.userData = { isBlock: true };
                const edges = new THREE.EdgesGeometry(geo);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.2, transparent: true }));
                voxel.add(line);
                scene.add(voxel);
                objects.push(voxel);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
                rollOverMesh.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
            }
        }

        function onPointerDown(event) {
            if(event.target.closest('.interactive-ui') || event.target.closest('#quiz-modal') || event.target.closest('#save-manager-modal')) return;
            startMousePos = { x: event.clientX, y: event.clientY };
            isDragging = false;
        }

        function onPointerUp(event) {
            if(event.target.closest('.interactive-ui') || event.target.closest('#quiz-modal') || event.target.closest('#save-manager-modal')) return;
            const dx = event.clientX - startMousePos.x;
            const dy = event.clientY - startMousePos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) return; 

            event.preventDefault();
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const isRightClick = event.button === 2;

                if (isRightClick || (activeTool === 'destroy' && !isRightClick)) {
                    if (intersect.object !== plane) {
                        scene.remove(intersect.object);
                        objects.splice(objects.indexOf(intersect.object), 1);
                        const p = intersect.object.position;
                        state.blocks = state.blocks.filter(b => !(b.x === p.x && b.y === p.y && b.z === p.z));
                        saveState();
                    }
                } 
                else if (activeTool === 'build' && !isRightClick) {
                    if (state.points <= 0) {
                        showToast("Nu ai suficiente puncte! Răspunde la întrebări.");
                        return;
                    }
                    const voxel = new THREE.Mesh(new THREE.BoxGeometry(50, 50, 50), materials[currentBlockType]);
                    voxel.position.copy(intersect.point).add(intersect.face.normal);
                    voxel.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
                    voxel.userData = { isBlock: true };
                    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(50, 50, 50));
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.2, transparent: true }));
                    voxel.add(line);
                    scene.add(voxel);
                    objects.push(voxel);
                    state.points--;
                    state.blocks.push({ x: voxel.position.x, y: voxel.position.y, z: voxel.position.z, type: currentBlockType });
                    saveState();
                }
            }
        }

        function onDocumentKeyDown(event) { 
            if(event.keyCode === 16) isShiftDown = true; 
            keysPressed[event.key.toLowerCase()] = true;
        }
        function onDocumentKeyUp(event) { 
            if(event.keyCode === 16) isShiftDown = false; 
            keysPressed[event.key.toLowerCase()] = false;
        }
        function animate() { 
            requestAnimationFrame(animate); 
            
            // Keyboard Movement Logic
            if (controls && camera) {
                const speed = 15; // Movement speed
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();

                let moved = false;

                // W or ArrowUp
                if (keysPressed['w'] || keysPressed['arrowup']) {
                    camera.position.addScaledVector(direction, speed);
                    controls.target.addScaledVector(direction, speed);
                    moved = true;
                }
                // S or ArrowDown
                if (keysPressed['s'] || keysPressed['arrowdown']) {
                    camera.position.addScaledVector(direction, -speed);
                    controls.target.addScaledVector(direction, -speed);
                    moved = true;
                }
                // A or ArrowLeft
                if (keysPressed['a'] || keysPressed['arrowleft']) {
                    camera.position.addScaledVector(right, -speed);
                    controls.target.addScaledVector(right, -speed);
                    moved = true;
                }
                // D or ArrowRight
                if (keysPressed['d'] || keysPressed['arrowright']) {
                    camera.position.addScaledVector(right, speed);
                    controls.target.addScaledVector(right, speed);
                    moved = true;
                }
                // E (Up)
                if (keysPressed['e']) {
                    camera.position.y += speed;
                    controls.target.y += speed;
                    moved = true;
                }
                // Q (Down)
                if (keysPressed['q']) {
                    camera.position.y -= speed;
                    controls.target.y -= speed;
                    moved = true;
                }

                if (moved) controls.update();
            }

            if (renderer && scene && camera) renderer.render(scene, camera); 
        }

        // Start Script
        window.onload = function() {
            try {
                initQuestions();
                initSaveSystem(); // Replaces loadState()
                init3D();
                animate();
                console.log("Game initialized successfully!");
            } catch (e) {
                console.error("Game Initialization Error:", e);
                alert("A apărut o eroare la încărcarea jocului. Te rugăm să reîncarci pagina.");
            }
        };

    </script>
</body>
</html>
